/* automatically generated by rust-bindgen 0.72.1 */

pub const BHS_EPSILON: f64 = 0.000000001;
pub const BHS_ENTITY_INVALID: u32 = 0;
pub const BHS_MAX_ENTITIES: u32 = 10000;
pub const BHS_MAX_TRAIL_POINTS: u32 = 65536;
pub const BHS_LOG_CHANNEL_ALL: u32 = 4294967295;
pub const BHS_COLOR_RESET: &[u8; 5] = b"\x1B[0m\0";
pub const BHS_COLOR_RED: &[u8; 6] = b"\x1B[31m\0";
pub const BHS_COLOR_GREEN: &[u8; 6] = b"\x1B[32m\0";
pub const BHS_COLOR_YELLOW: &[u8; 6] = b"\x1B[33m\0";
pub const BHS_COLOR_BLUE: &[u8; 6] = b"\x1B[34m\0";
pub const BHS_COLOR_MAGENTA: &[u8; 6] = b"\x1B[35m\0";
pub const BHS_COLOR_CYAN: &[u8; 6] = b"\x1B[36m\0";
pub const BHS_COLOR_WHITE: &[u8; 6] = b"\x1B[37m\0";
pub const BHS_COLOR_GRAY: &[u8; 6] = b"\x1B[90m\0";
pub type real_t = f64;
#[doc = " struct bhs_vec4 - Vetor 4D em espaço-tempo\n @t: componente temporal (x^0)\n @x: componente espacial x (x^1)\n @y: componente espacial y (x^2)\n @z: componente espacial z (x^3)\n\n Pode representar:\n - Posição 4D (evento no espaço-tempo)\n - 4-velocidade (u^μ = dx^μ/dτ)\n - 4-momento (p^μ = m*u^μ)\n - Qualquer 4-vetor contravariante"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_vec4 {
    pub t: real_t,
    pub x: real_t,
    pub y: real_t,
    pub z: real_t,
}
#[doc = " struct bhs_vec3 - Vetor 3D espacial (pra facilitar)\n\n Usado quando só a parte espacial importa."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_vec3 {
    pub x: real_t,
    pub y: real_t,
    pub z: real_t,
}
unsafe extern "C" {
    #[doc = " bhs_vec4_add - Soma de vetores"]
    pub fn bhs_vec4_add(a: bhs_vec4, b: bhs_vec4) -> bhs_vec4;
}
unsafe extern "C" {
    #[doc = " bhs_vec4_sub - Subtração de vetores"]
    pub fn bhs_vec4_sub(a: bhs_vec4, b: bhs_vec4) -> bhs_vec4;
}
unsafe extern "C" {
    #[doc = " bhs_vec4_scale - Multiplicação por escalar"]
    pub fn bhs_vec4_scale(v: bhs_vec4, s: real_t) -> bhs_vec4;
}
unsafe extern "C" {
    #[doc = " bhs_vec4_neg - Negação (inverte sinal)"]
    pub fn bhs_vec4_neg(v: bhs_vec4) -> bhs_vec4;
}
unsafe extern "C" {
    #[doc = " bhs_vec4_dot_minkowski - Produto interno com métrica de Minkowski\n\n η_μν = diag(-1, +1, +1, +1)\n\n Retorna: -t1*t2 + x1*x2 + y1*y2 + z1*z2\n\n Para 4-velocidade u^μ de partícula com massa:\n   η_μν u^μ u^ν = -1 (normalização)\n\n Para 4-vetor nulo (fótons):\n   η_μν k^μ k^ν = 0"]
    pub fn bhs_vec4_dot_minkowski(a: bhs_vec4, b: bhs_vec4) -> real_t;
}
unsafe extern "C" {
    #[doc = " bhs_vec4_norm2_minkowski - Norma ao quadrado (Minkowski)\n\n Retorna: η_μν v^μ v^ν = -t² + x² + y² + z²\n\n Pode ser:\n   < 0 : timelike (interval de tempo)\n   = 0 : null/lightlike (fótons)\n   > 0 : spacelike (intervalo espacial)"]
    pub fn bhs_vec4_norm2_minkowski(v: bhs_vec4) -> real_t;
}
unsafe extern "C" {
    #[doc = " bhs_vec4_is_null - Verifica se é vetor nulo (fóton)\n\n Tolerância: |norm²| < epsilon"]
    pub fn bhs_vec4_is_null(v: bhs_vec4, epsilon: real_t) -> bool;
}
unsafe extern "C" {
    #[doc = " bhs_vec4_is_timelike - Verifica se é timelike"]
    pub fn bhs_vec4_is_timelike(v: bhs_vec4) -> bool;
}
unsafe extern "C" {
    #[doc = " bhs_vec4_is_spacelike - Verifica se é spacelike"]
    pub fn bhs_vec4_is_spacelike(v: bhs_vec4) -> bool;
}
unsafe extern "C" {
    #[doc = " bhs_vec3_add - Soma de vetores 3D"]
    pub fn bhs_vec3_add(a: bhs_vec3, b: bhs_vec3) -> bhs_vec3;
}
unsafe extern "C" {
    #[doc = " bhs_vec3_sub - Subtração de vetores 3D"]
    pub fn bhs_vec3_sub(a: bhs_vec3, b: bhs_vec3) -> bhs_vec3;
}
unsafe extern "C" {
    #[doc = " bhs_vec3_scale - Multiplicação por escalar"]
    pub fn bhs_vec3_scale(v: bhs_vec3, s: real_t) -> bhs_vec3;
}
unsafe extern "C" {
    #[doc = " bhs_vec3_dot - Produto escalar euclidiano"]
    pub fn bhs_vec3_dot(a: bhs_vec3, b: bhs_vec3) -> real_t;
}
unsafe extern "C" {
    #[doc = " bhs_vec3_cross - Produto vetorial"]
    pub fn bhs_vec3_cross(a: bhs_vec3, b: bhs_vec3) -> bhs_vec3;
}
unsafe extern "C" {
    #[doc = " bhs_vec3_norm - Norma euclidiana (magnitude)"]
    pub fn bhs_vec3_norm(v: bhs_vec3) -> real_t;
}
unsafe extern "C" {
    #[doc = " bhs_vec3_norm2 - Norma ao quadrado (evita sqrt)"]
    pub fn bhs_vec3_norm2(v: bhs_vec3) -> real_t;
}
unsafe extern "C" {
    #[doc = " bhs_vec3_normalize - Retorna vetor unitário\n\n Se v = 0, retorna vetor zero (não explode)."]
    pub fn bhs_vec3_normalize(v: bhs_vec3) -> bhs_vec3;
}
unsafe extern "C" {
    #[doc = " bhs_vec3_to_spherical - Cartesianas para esféricas\n @v: vetor em coordenadas cartesianas (x, y, z)\n @r: [out] raio\n @theta: [out] ângulo polar (0 a π)\n @phi: [out] ângulo azimutal (-π a π)"]
    pub fn bhs_vec3_to_spherical(v: bhs_vec3, r: *mut real_t, theta: *mut real_t, phi: *mut real_t);
}
unsafe extern "C" {
    #[doc = " bhs_vec3_from_spherical - Esféricas para cartesianas"]
    pub fn bhs_vec3_from_spherical(r: real_t, theta: real_t, phi: real_t) -> bhs_vec3;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_scene_impl {
    _unused: [u8; 0],
}
pub type bhs_scene_t = *mut bhs_scene_impl;
pub type bhs_entity_id = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_world_t {
    _unused: [u8; 0],
}
pub type bhs_world_handle = *mut bhs_world_t;
unsafe extern "C" {
    pub fn bhs_ecs_create_world() -> bhs_world_handle;
}
unsafe extern "C" {
    pub fn bhs_ecs_destroy_world(world: bhs_world_handle);
}
unsafe extern "C" {
    pub fn bhs_ecs_create_entity(world: bhs_world_handle) -> bhs_entity_id;
}
unsafe extern "C" {
    pub fn bhs_ecs_destroy_entity(world: bhs_world_handle, entity: bhs_entity_id);
}
pub type bhs_component_type = u32;
unsafe extern "C" {
    pub fn bhs_ecs_add_component(
        world: bhs_world_handle,
        entity: bhs_entity_id,
        type_: bhs_component_type,
        size: usize,
        data: *const core::ffi::c_void,
    ) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn bhs_ecs_remove_component(
        world: bhs_world_handle,
        entity: bhs_entity_id,
        type_: bhs_component_type,
    );
}
unsafe extern "C" {
    pub fn bhs_ecs_get_component(
        world: bhs_world_handle,
        entity: bhs_entity_id,
        type_: bhs_component_type,
    ) -> *mut core::ffi::c_void;
}
pub type bhs_component_mask = u32;
#[doc = " Query para iteração eficiente sobre entidades.\n\n Uso:\n   bhs_ecs_query q;\n   bhs_ecs_query_init(&q, world, (1 << BHS_COMP_TRANSFORM) | (1 << BHS_COMP_PHYSICS));\n\n   bhs_entity_id e;\n   while (bhs_ecs_query_next(&q, &e)) {\n       // Processar entidade\n   }"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_ecs_query {
    pub world: bhs_world_handle,
    pub required: bhs_component_mask,
    pub current_idx: u32,
    pub count: u32,
    pub cache: *mut bhs_entity_id,
    pub use_cache: bool,
}
unsafe extern "C" {
    #[doc = " bhs_ecs_query_init - Inicializa query com máscara de componentes\n @q: Ponteiro para query a inicializar\n @world: Mundo ECS\n @required: Bitmask de componentes necessários (1 << BHS_COMP_X | ...)\n\n Modos:\n - Sem cache: Itera todas entidades e filtra on-the-fly (baixa memória)\n - Com cache: Pre-computa lista de matches (mais rápido para muitas iterações)"]
    pub fn bhs_ecs_query_init(
        q: *mut bhs_ecs_query,
        world: bhs_world_handle,
        required: bhs_component_mask,
    );
}
unsafe extern "C" {
    #[doc = " bhs_ecs_query_init_cached - Versão que pré-computa entidades\n\n Mais rápido se você vai iterar múltiplas vezes ou precisa contar.\n Aloca memória, lembre de chamar bhs_ecs_query_destroy."]
    pub fn bhs_ecs_query_init_cached(
        q: *mut bhs_ecs_query,
        world: bhs_world_handle,
        required: bhs_component_mask,
    );
}
unsafe extern "C" {
    #[doc = " bhs_ecs_query_next - Avança para próxima entidade matching\n @q: Query\n @out_entity: [out] ID da entidade encontrada\n\n Retorna: true se encontrou, false se acabou"]
    pub fn bhs_ecs_query_next(q: *mut bhs_ecs_query, out_entity: *mut bhs_entity_id) -> bool;
}
unsafe extern "C" {
    #[doc = " bhs_ecs_query_reset - Reinicia iteração do início"]
    pub fn bhs_ecs_query_reset(q: *mut bhs_ecs_query);
}
unsafe extern "C" {
    #[doc = " bhs_ecs_query_destroy - Libera recursos da query (se usou cache)"]
    pub fn bhs_ecs_query_destroy(q: *mut bhs_ecs_query);
}
unsafe extern "C" {
    #[doc = " bhs_ecs_entity_has_components - Verifica se entidade tem todos os componentes\n @world: Mundo ECS\n @entity: ID da entidade\n @mask: Bitmask de componentes a verificar\n\n Retorna: true se entidade possui TODOS os componentes da máscara"]
    pub fn bhs_ecs_entity_has_components(
        world: bhs_world_handle,
        entity: bhs_entity_id,
        mask: bhs_component_mask,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " bhs_ecs_save_world - Salva todo o estado do mundo em arquivo binário.\n @world: Mundo a salvar\n @filename: Caminho do arquivo\n Retorna true se sucesso."]
    pub fn bhs_ecs_save_world(world: bhs_world_handle, filename: *const core::ffi::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = " bhs_ecs_load_world - Carrega estado do mundo (sobrescreve atual).\n @world: Mundo a carregar\n @filename: Caminho do arquivo\n Retorna true se sucesso."]
    pub fn bhs_ecs_load_world(world: bhs_world_handle, filename: *const core::ffi::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = " @brief Lê apenas um componente específico do arquivo sem carregar o mundo todo.\n Útil para ler metadados (título, data) de múltiplos arquivos rapidamente."]
    pub fn bhs_ecs_peek_metadata(
        filename: *const core::ffi::c_char,
        out_metadata: *mut core::ffi::c_void,
        metadata_size: usize,
        metadata_type_id: u32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " bhs_ecs_update_metadata - Atualiza metadados sem carregar o mundo todo\n\n Abre o arquivo modo rb+, acha o chunk de metadados e sobrescreve.\n Requer que o tamanho da struct seja compatível."]
    pub fn bhs_ecs_update_metadata(
        filename: *const core::ffi::c_char,
        new_metadata: *const core::ffi::c_void,
        metadata_size: usize,
        metadata_type_id: u32,
    ) -> bool;
}
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __gnuc_va_list;
#[doc = " struct bhs_metric - Tensor métrico covariante g_μν\n\n Matriz 4x4 simétrica: g[μ][ν] = g[ν][μ]\n Índices: 0=t, 1=x/r, 2=y/θ, 3=z/φ\n\n Alinhamento 16 bytes para compatibilidade com GPU (std140/std430)"]
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct bhs_metric {
    pub g: [[real_t; 4usize]; 4usize],
}
#[doc = " struct bhs_christoffel - Símbolos de Christoffel Γ^α_μν\n\n Conexão de Levi-Civita, simétrica nos índices inferiores.\n Γ[α][μ][ν] = Γ[α][ν][μ]"]
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct bhs_christoffel {
    pub gamma: [[[real_t; 4usize]; 4usize]; 4usize],
}
unsafe extern "C" {
    #[doc = " Métrica de Minkowski (espaço plano)"]
    pub static BHS_MINKOWSKI: bhs_metric;
}
unsafe extern "C" {
    #[doc = " bhs_metric_zero - Métrica zerada"]
    pub fn bhs_metric_zero() -> bhs_metric;
}
unsafe extern "C" {
    #[doc = " bhs_metric_minkowski - Retorna métrica de Minkowski\n\n η_μν = diag(-1, +1, +1, +1)"]
    pub fn bhs_metric_minkowski() -> bhs_metric;
}
unsafe extern "C" {
    #[doc = " bhs_metric_diag - Cria métrica diagonal\n @g00, g11, g22, g33: elementos da diagonal\n\n Útil pra métricas esféricas onde só a diagonal importa."]
    pub fn bhs_metric_diag(g00: real_t, g11: real_t, g22: real_t, g33: real_t) -> bhs_metric;
}
unsafe extern "C" {
    #[doc = " bhs_metric_is_symmetric - Verifica simetria\n\n Retorna true se g[μ][ν] = g[ν][μ] para todos μ, ν."]
    pub fn bhs_metric_is_symmetric(m: *const bhs_metric, tol: real_t) -> bool;
}
unsafe extern "C" {
    #[doc = " bhs_metric_det - Determinante da métrica\n\n Retorna det(g_μν).\n Para métricas diagonais: g00 * g11 * g22 * g33\n\n O determinante é usado para calcular elementos de volume:\n dV = √|g| d⁴x"]
    pub fn bhs_metric_det(m: *const bhs_metric) -> real_t;
}
unsafe extern "C" {
    #[doc = " bhs_metric_invert - Inverte a métrica\n @m: métrica covariante g_μν\n @inv: [out] métrica contravariante g^μν\n\n Calcula g^μν tal que g^μα g_αν = δ^μ_ν\n\n Retorna:\n   0 em sucesso\n  -1 se matriz singular (det ≈ 0)"]
    pub fn bhs_metric_invert(m: *const bhs_metric, inv: *mut bhs_metric) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " bhs_metric_lower - Abaixa índice de vetor (contravariante → covariante)\n @m: métrica g_μν\n @v: vetor contravariante v^μ\n\n Retorna: v_μ = g_μν v^ν"]
    pub fn bhs_metric_lower(m: *const bhs_metric, v: bhs_vec4) -> bhs_vec4;
}
unsafe extern "C" {
    #[doc = " bhs_metric_raise - Levanta índice de vetor (covariante → contravariante)\n @m_inv: métrica inversa g^μν\n @v: vetor covariante v_μ\n\n Retorna: v^μ = g^μν v_ν"]
    pub fn bhs_metric_raise(m_inv: *const bhs_metric, v: bhs_vec4) -> bhs_vec4;
}
unsafe extern "C" {
    #[doc = " bhs_metric_dot - Produto interno com métrica geral\n @m: métrica g_μν\n @a, @b: vetores contravariantes\n\n Retorna: g_μν a^μ b^ν"]
    pub fn bhs_metric_dot(m: *const bhs_metric, a: bhs_vec4, b: bhs_vec4) -> real_t;
}
#[doc = " Ponteiro de função para métrica parametrizada\n\n @coords: coordenadas (t, r/x, θ/y, φ/z) dependendo do sistema\n @userdata: parâmetros adicionais (massa, spin, etc.)\n @out: métrica calculada nesse ponto"]
pub type bhs_metric_func = ::core::option::Option<
    unsafe extern "C" fn(coords: bhs_vec4, userdata: *mut core::ffi::c_void, out: *mut bhs_metric),
>;
unsafe extern "C" {
    #[doc = " bhs_christoffel_compute - Calcula símbolos de Christoffel numericamente\n @metric_fn: função que retorna a métrica em um ponto\n @coords: ponto onde calcular\n @userdata: parâmetros passados para metric_fn\n @h: tamanho do passo para diferença finita\n @out: [out] símbolos de Christoffel Γ^α_μν\n\n Usa diferença central: ∂_μ g ≈ [g(x+h) - g(x-h)] / (2h)\n\n Retorna:\n   0 em sucesso\n  -1 se falhou (métrica singular)"]
    pub fn bhs_christoffel_compute(
        metric_fn: bhs_metric_func,
        coords: bhs_vec4,
        userdata: *mut core::ffi::c_void,
        h: real_t,
        out: *mut bhs_christoffel,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " bhs_christoffel_zero - Christoffel zerado (espaço plano)"]
    pub fn bhs_christoffel_zero() -> bhs_christoffel;
}
unsafe extern "C" {
    #[doc = " bhs_geodesic_accel - Calcula aceleração geodésica\n @chris: símbolos de Christoffel\n @vel: 4-velocidade u^μ = dx^μ/dλ\n\n Retorna: a^α = -Γ^α_μν u^μ u^ν\n\n Esta é a aceleração que aparece na equação de geodésica:\n d²x^α/dλ² = -Γ^α_μν (dx^μ/dλ)(dx^ν/dλ)"]
    pub fn bhs_geodesic_accel(chris: *const bhs_christoffel, vel: bhs_vec4) -> bhs_vec4;
}
#[doc = " struct bhs_kerr - Parâmetros do buraco negro de Kerr\n @M: Massa do buraco negro (em unidades geométricas, G = c = 1)\n @a: Parâmetro de spin: a = J / (Mc), onde J é momento angular\n\n Restrição física: |a| ≤ M\n - a = 0: Schwarzschild (sem rotação)\n - a = M: Kerr extremo (rotação máxima)\n - |a| > M: Kerr super-extremo (singularidade nua, não é buraco negro)\n\n O Gargantua do Interestelar tem a/M ≈ 0.998 (quase extremo)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_kerr {
    pub M: f64,
    pub a: f64,
}
unsafe extern "C" {
    #[doc = " bhs_kerr_horizon_outer - Horizonte de eventos externo r+\n\n r+ = M + √(M² - a²)\n\n Este é O horizonte de eventos. Nada escapa de r < r+.\n Para a = 0: r+ = 2M (Schwarzschild)\n Para a = M: r+ = M (Kerr extremo)"]
    pub fn bhs_kerr_horizon_outer(bh: *const bhs_kerr) -> f64;
}
unsafe extern "C" {
    #[doc = " bhs_kerr_horizon_inner - Horizonte de Cauchy interno r-\n\n r- = M - √(M² - a²)\n\n Horizonte interno. Instável classicamente.\n Para a = 0: r- = 0\n Para a = M: r- = M (coincide com r+)"]
    pub fn bhs_kerr_horizon_inner(bh: *const bhs_kerr) -> f64;
}
unsafe extern "C" {
    #[doc = " bhs_kerr_ergosphere - Raio da ergoesfera\n\n r_ergo(θ) = M + √(M² - a² cos²θ)\n\n Na ergoesfera (r+ < r < r_ergo), observadores estáticos são impossíveis.\n Tudo é forçado a co-rotar com o buraco negro (frame dragging).\n\n Máxima extensão no equador (θ = π/2): r_ergo = 2M\n Coincide com r+ nos polos (θ = 0, π)"]
    pub fn bhs_kerr_ergosphere(bh: *const bhs_kerr, theta: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " bhs_kerr_isco - ISCO (Innermost Stable Circular Orbit)\n @prograde: true para órbita prograde (co-rotação), false para retrógrada\n\n Para Kerr, o ISCO depende da direção da órbita:\n - Prograde: r_isco decresce com spin (até r = M para a = M)\n - Retrógrada: r_isco aumenta com spin (até r = 9M para a = M)\n\n Para a = 0: r_isco = 6M (mesmo que Schwarzschild)"]
    pub fn bhs_kerr_isco(bh: *const bhs_kerr, prograde: bool) -> f64;
}
unsafe extern "C" {
    #[doc = " bhs_kerr_omega_frame - Velocidade angular do frame dragging\n\n ω = -g_tφ / g_φφ = 2Mar / [(r² + a²)² - a²Δ sin²θ]\n\n É a velocidade angular com que um observador ZAMO (Zero Angular Momentum\n Observer) é arrastado pelo espaço-tempo rotativo.\n\n No horizonte: ω_H = a / (2Mr+) - velocidade angular do buraco negro."]
    pub fn bhs_kerr_omega_frame(bh: *const bhs_kerr, r: f64, theta: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " bhs_kerr_metric - Calcula tensor métrico de Kerr\n @bh: parâmetros do buraco negro\n @r: coordenada radial (deve ser > r+ fora do horizonte)\n @theta: ângulo polar [0, π]\n @out: [out] tensor métrico g_μν\n\n Linha de mundo em Boyer-Lindquist:\n ds² = -(1 - 2Mr/Σ)dt² - (4Mar sin²θ/Σ) dt dφ\n       + (Σ/Δ)dr² + Σ dθ² + [(r²+a²)² - a²Δ sin²θ]/Σ sin²θ dφ²\n\n Componentes não-diagonais: g_tφ ≠ 0 (frame dragging!)"]
    pub fn bhs_kerr_metric(bh: *const bhs_kerr, r: f64, theta: f64, out: *mut bhs_metric);
}
unsafe extern "C" {
    #[doc = " bhs_kerr_metric_inverse - Calcula métrica inversa g^μν"]
    pub fn bhs_kerr_metric_inverse(bh: *const bhs_kerr, r: f64, theta: f64, out: *mut bhs_metric);
}
unsafe extern "C" {
    #[doc = " bhs_kerr_redshift_zamo - Redshift para observador ZAMO\n @bh: parâmetros\n @r: coordenada radial\n @theta: ângulo polar\n\n O observador ZAMO é \"estacionário\" no espaço-tempo rotativo\n (momento angular zero relativo ao infinito)."]
    pub fn bhs_kerr_redshift_zamo(bh: *const bhs_kerr, r: f64, theta: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " bhs_kerr_metric_func - Wrapper para bhs_christoffel_compute\n\n Use como bhs_metric_func com userdata = struct bhs_kerr*\n\n Coordenadas em vec4: (t, r, θ, φ)"]
    pub fn bhs_kerr_metric_func(
        coords: bhs_vec4,
        userdata: *mut core::ffi::c_void,
        out: *mut bhs_metric,
    );
}
#[doc = " struct bhs_schwarzschild - Parâmetros do buraco negro de Schwarzschild\n @M: Massa do buraco negro (em unidades geométricas: G = c = 1)\n\n Raio de Schwarzschild: rs = 2M\n\n Em unidades SI:\n rs = 2GM/c² ≈ 2.95 km * (M/M_sol)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_schwarzschild {
    pub M: f64,
}
unsafe extern "C" {
    #[doc = " bhs_schwarzschild_metric - Calcula tensor métrico\n @bh: parâmetros do buraco negro\n @r: coordenada radial (deve ser > rs para evitar singularidade)\n @theta: ângulo polar [0, π]\n @out: [out] tensor métrico g_μν\n\n Linha de mundo:\n ds² = -(1 - rs/r) dt² + (1 - rs/r)^(-1) dr² + r² dθ² + r² sin²θ dφ²\n\n Componentes:\n g_tt = -(1 - rs/r)\n g_rr = 1/(1 - rs/r)\n g_θθ = r²\n g_φφ = r² sin²θ"]
    pub fn bhs_schwarzschild_metric(
        bh: *const bhs_schwarzschild,
        r: f64,
        theta: f64,
        out: *mut bhs_metric,
    );
}
unsafe extern "C" {
    #[doc = " bhs_schwarzschild_metric_inverse - Calcula métrica inversa g^μν"]
    pub fn bhs_schwarzschild_metric_inverse(
        bh: *const bhs_schwarzschild,
        r: f64,
        theta: f64,
        out: *mut bhs_metric,
    );
}
unsafe extern "C" {
    #[doc = " bhs_schwarzschild_redshift - Fator de redshift gravitacional\n @bh: parâmetros\n @r: coordenada radial\n\n Retorna: z = 1/√(1 - rs/r) - 1\n\n Luz emitida em r chega ao infinito com frequência reduzida por (1 + z).\n No horizonte (r = rs): z → ∞ (redshift infinito)"]
    pub fn bhs_schwarzschild_redshift(bh: *const bhs_schwarzschild, r: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " bhs_schwarzschild_escape_velocity - Velocidade de escape\n @bh: parâmetros\n @r: coordenada radial\n\n Retorna: v_esc = √(rs/r) = √(2M/r)\n\n No horizonte: v_esc = c (1.0 em unidades naturais)"]
    pub fn bhs_schwarzschild_escape_velocity(bh: *const bhs_schwarzschild, r: f64) -> f64;
}
unsafe extern "C" {
    #[doc = " bhs_schwarzschild_metric_func - Wrapper para bhs_christoffel_compute\n\n Use como bhs_metric_func com userdata = struct bhs_schwarzschild*\n\n Coordenadas em vec4: (t, r, θ, φ)"]
    pub fn bhs_schwarzschild_metric_func(
        coords: bhs_vec4,
        userdata: *mut core::ffi::c_void,
        out: *mut bhs_metric,
    );
}
unsafe extern "C" {
    #[doc = " bhs_engine_init - Inicializa subsistemas (Memory, ECS, Physics)\n\n Deve ser chamado antes de qualquer outra funcao da engine."]
    pub fn bhs_engine_init();
}
unsafe extern "C" {
    #[doc = " bhs_engine_shutdown - Libera todos os recursos"]
    pub fn bhs_engine_shutdown();
}
unsafe extern "C" {
    #[doc = " bhs_engine_update - Avanca a simulacao\n @dt: Delta time em segundos (step fixo recomendado para fisica)\n\n Executa:\n 1. Physics System (Integrator)\n 2. Spacetime System (Metric Updates)\n 3. Script/Game Logic Systems"]
    pub fn bhs_engine_update(dt: f64);
}
unsafe extern "C" {
    #[doc = " bhs_scene_load - Carrega uma cena (planetas, config)\n @path: Caminho para o arquivo ou string de definicao\n\n Por enquanto, hardcoded ou script simples.\n Futuro: JSON/Binary serialization."]
    pub fn bhs_scene_load(path: *const core::ffi::c_char);
}
pub const bhs_body_type_BHS_BODY_PLANET: bhs_body_type = 0;
pub const bhs_body_type_BHS_BODY_MOON: bhs_body_type = 1;
pub const bhs_body_type_BHS_BODY_STAR: bhs_body_type = 2;
pub const bhs_body_type_BHS_BODY_BLACKHOLE: bhs_body_type = 3;
pub const bhs_body_type_BHS_BODY_ASTEROID: bhs_body_type = 4;
pub type bhs_body_type = core::ffi::c_uint;
pub const bhs_matter_state_BHS_STATE_SOLID: bhs_matter_state = 0;
pub const bhs_matter_state_BHS_STATE_LIQUID: bhs_matter_state = 1;
pub const bhs_matter_state_BHS_STATE_GAS: bhs_matter_state = 2;
pub const bhs_matter_state_BHS_STATE_PLASMA: bhs_matter_state = 3;
pub type bhs_matter_state = core::ffi::c_uint;
pub const bhs_shape_type_BHS_SHAPE_SPHERE: bhs_shape_type = 0;
pub const bhs_shape_type_BHS_SHAPE_ELLIPSOID: bhs_shape_type = 1;
pub const bhs_shape_type_BHS_SHAPE_IRREGULAR: bhs_shape_type = 2;
pub type bhs_shape_type = core::ffi::c_uint;
pub const bhs_star_stage_BHS_STAR_MAIN_SEQUENCE: bhs_star_stage = 0;
pub const bhs_star_stage_BHS_STAR_GIANT: bhs_star_stage = 1;
pub const bhs_star_stage_BHS_STAR_WHITE_DWARF: bhs_star_stage = 2;
pub const bhs_star_stage_BHS_STAR_NEUTRON: bhs_star_stage = 3;
pub type bhs_star_stage = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_planet_data {
    pub density: f64,
    pub axis_tilt: f64,
    pub rotation_period: f64,
    pub j2: f64,
    pub albedo: f64,
    pub has_atmosphere: bool,
    pub surface_pressure: f64,
    pub atmosphere_mass: f64,
    pub composition: [core::ffi::c_char; 64usize],
    pub temperature: f64,
    pub heat_capacity: f64,
    pub energy_flux: f64,
    pub physical_state: core::ffi::c_int,
    pub has_magnetic_field: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_star_data {
    pub luminosity: f64,
    pub temp_effective: f64,
    pub age: f64,
    pub density: f64,
    pub hydrogen_frac: f64,
    pub helium_frac: f64,
    pub metals_frac: f64,
    pub stage: core::ffi::c_int,
    pub metallicity: f64,
    pub spectral_type: [core::ffi::c_char; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_blackhole_data {
    pub spin_factor: f64,
    pub event_horizon_r: f64,
    pub ergososphere_r: f64,
    pub accretion_disk_mass: f64,
    pub accretion_rate: f64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_body_state {
    pub pos: bhs_vec3,
    pub vel: bhs_vec3,
    pub acc: bhs_vec3,
    pub rot_axis: bhs_vec3,
    pub rot_speed: f64,
    pub moment_inertia: f64,
    pub mass: f64,
    pub radius: f64,
    pub current_rotation_angle: f64,
    pub shape: core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bhs_body {
    pub state: bhs_body_state,
    pub type_: bhs_body_type,
    pub prop: bhs_body__bindgen_ty_1,
    pub color: bhs_vec3,
    pub is_fixed: bool,
    pub is_alive: bool,
    pub name: [core::ffi::c_char; 32usize],
    pub trail_positions: [[f32; 3usize]; 65536usize],
    pub trail_head: core::ffi::c_int,
    pub trail_count: core::ffi::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bhs_body__bindgen_ty_1 {
    pub planet: bhs_planet_data,
    pub star: bhs_star_data,
    pub bh: bhs_blackhole_data,
}
unsafe extern "C" {
    pub fn bhs_scene_create() -> bhs_scene_t;
}
unsafe extern "C" {
    pub fn bhs_scene_destroy(scene: bhs_scene_t);
}
unsafe extern "C" {
    pub fn bhs_scene_init_default(scene: bhs_scene_t);
}
unsafe extern "C" {
    pub fn bhs_scene_update(scene: bhs_scene_t, dt: f64);
}
unsafe extern "C" {
    pub fn bhs_scene_get_world(scene: bhs_scene_t) -> bhs_world_handle;
}
unsafe extern "C" {
    pub fn bhs_scene_get_bodies(
        scene: bhs_scene_t,
        count: *mut core::ffi::c_int,
    ) -> *const bhs_body;
}
unsafe extern "C" {
    pub fn bhs_scene_add_body_struct(scene: bhs_scene_t, b: bhs_body) -> bhs_entity_id;
}
unsafe extern "C" {
    pub fn bhs_scene_add_body(
        scene: bhs_scene_t,
        type_: bhs_body_type,
        pos: bhs_vec3,
        vel: bhs_vec3,
        mass: f64,
        radius: f64,
        color: bhs_vec3,
    ) -> bhs_entity_id;
}
unsafe extern "C" {
    pub fn bhs_scene_add_body_named(
        scene: bhs_scene_t,
        type_: bhs_body_type,
        pos: bhs_vec3,
        vel: bhs_vec3,
        mass: f64,
        radius: f64,
        color: bhs_vec3,
        name: *const core::ffi::c_char,
    ) -> bhs_entity_id;
}
unsafe extern "C" {
    pub fn bhs_scene_remove_body(scene: bhs_scene_t, index: core::ffi::c_int);
}
unsafe extern "C" {
    pub fn bhs_scene_reset_counters();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_planet_desc {
    _unused: [u8; 0],
}
unsafe extern "C" {
    pub fn bhs_body_create_planet_simple(
        pos: bhs_vec3,
        mass: f64,
        radius: f64,
        color: bhs_vec3,
    ) -> bhs_body;
}
unsafe extern "C" {
    pub fn bhs_body_create_star_simple(
        pos: bhs_vec3,
        mass: f64,
        radius: f64,
        color: bhs_vec3,
    ) -> bhs_body;
}
unsafe extern "C" {
    pub fn bhs_body_create_blackhole_simple(pos: bhs_vec3, mass: f64, radius: f64) -> bhs_body;
}
unsafe extern "C" {
    pub fn bhs_body_create_from_desc(desc: *const bhs_planet_desc, pos: bhs_vec3) -> bhs_body;
}
pub const bhs_sun_stage_BHS_SUN_MAIN_SEQUENCE: bhs_sun_stage = 0;
pub const bhs_sun_stage_BHS_SUN_RED_GIANT: bhs_sun_stage = 1;
pub const bhs_sun_stage_BHS_SUN_WHITE_DWARF: bhs_sun_stage = 2;
pub const bhs_sun_stage_BHS_SUN_NEUTRON_STAR: bhs_sun_stage = 3;
pub type bhs_sun_stage = core::ffi::c_uint;
#[doc = " @brief Descritor Físico de uma Estrela"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_sun_desc {
    pub name: *const core::ffi::c_char,
    pub mass: f64,
    pub radius: f64,
    pub temperature: f64,
    pub luminosity: f64,
    pub age: f64,
    pub metallicity: f64,
    pub stage: bhs_sun_stage,
    pub spectral_type: [core::ffi::c_char; 8usize],
    pub rotation_period: f64,
    pub axis_tilt: f64,
    pub base_color: bhs_vec3,
    pub get_surface_color:
        ::core::option::Option<unsafe extern "C" fn(p_local: bhs_vec3) -> bhs_vec3>,
}
#[doc = " @brief Descritor Físico de um Buraco Negro"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_blackhole_desc {
    pub name: *const core::ffi::c_char,
    pub mass: f64,
    pub spin: f64,
    pub charge: f64,
    pub event_horizon_r: f64,
    pub accretion_disk_mass: f64,
    pub base_color: bhs_vec3,
    pub get_surface_color:
        ::core::option::Option<unsafe extern "C" fn(p_local: bhs_vec3) -> bhs_vec3>,
}
unsafe extern "C" {
    pub fn bhs_body_create_from_sun_desc(desc: *const bhs_sun_desc, pos: bhs_vec3) -> bhs_body;
}
unsafe extern "C" {
    pub fn bhs_body_create_from_bh_desc(desc: *const bhs_blackhole_desc, pos: bhs_vec3)
        -> bhs_body;
}
#[doc = " @struct bhs_gravity_well\n @brief Define um ponto de massa que distorce a malha"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_gravity_well {
    pub pos: bhs_vec4,
    pub mass: f32,
    pub radius: f32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_gpu_device_impl {
    _unused: [u8; 0],
}
pub type bhs_gpu_device_t = *mut bhs_gpu_device_impl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_gpu_queue_impl {
    _unused: [u8; 0],
}
pub type bhs_gpu_queue_t = *mut bhs_gpu_queue_impl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_gpu_buffer_impl {
    _unused: [u8; 0],
}
pub type bhs_gpu_buffer_t = *mut bhs_gpu_buffer_impl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_gpu_texture_impl {
    _unused: [u8; 0],
}
pub type bhs_gpu_texture_t = *mut bhs_gpu_texture_impl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_gpu_sampler_impl {
    _unused: [u8; 0],
}
pub type bhs_gpu_sampler_t = *mut bhs_gpu_sampler_impl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_gpu_shader_impl {
    _unused: [u8; 0],
}
pub type bhs_gpu_shader_t = *mut bhs_gpu_shader_impl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_gpu_pipeline_impl {
    _unused: [u8; 0],
}
pub type bhs_gpu_pipeline_t = *mut bhs_gpu_pipeline_impl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_gpu_cmd_buffer_impl {
    _unused: [u8; 0],
}
pub type bhs_gpu_cmd_buffer_t = *mut bhs_gpu_cmd_buffer_impl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_gpu_fence_impl {
    _unused: [u8; 0],
}
pub type bhs_gpu_fence_t = *mut bhs_gpu_fence_impl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_gpu_swapchain_impl {
    _unused: [u8; 0],
}
pub type bhs_gpu_swapchain_t = *mut bhs_gpu_swapchain_impl;
pub const bhs_gpu_error_BHS_GPU_OK: bhs_gpu_error = 0;
pub const bhs_gpu_error_BHS_GPU_ERR_NOMEM: bhs_gpu_error = -1;
pub const bhs_gpu_error_BHS_GPU_ERR_DEVICE: bhs_gpu_error = -2;
pub const bhs_gpu_error_BHS_GPU_ERR_INVALID: bhs_gpu_error = -3;
pub const bhs_gpu_error_BHS_GPU_ERR_COMPILE: bhs_gpu_error = -4;
pub const bhs_gpu_error_BHS_GPU_ERR_UNSUPPORTED: bhs_gpu_error = -5;
pub const bhs_gpu_error_BHS_GPU_ERR_LOST: bhs_gpu_error = -6;
pub const bhs_gpu_error_BHS_GPU_ERR_TIMEOUT: bhs_gpu_error = -7;
pub const bhs_gpu_error_BHS_GPU_ERR_SWAPCHAIN: bhs_gpu_error = -8;
pub const bhs_gpu_error_BHS_GPU_ERR_SWAPCHAIN_RESIZE: bhs_gpu_error = -9;
pub type bhs_gpu_error = core::ffi::c_int;
pub const bhs_gpu_backend_BHS_GPU_BACKEND_AUTO: bhs_gpu_backend = 0;
pub const bhs_gpu_backend_BHS_GPU_BACKEND_METAL: bhs_gpu_backend = 1;
pub const bhs_gpu_backend_BHS_GPU_BACKEND_VULKAN: bhs_gpu_backend = 2;
pub const bhs_gpu_backend_BHS_GPU_BACKEND_DX12: bhs_gpu_backend = 3;
pub const bhs_gpu_backend_BHS_GPU_BACKEND_OPENGL: bhs_gpu_backend = 4;
pub type bhs_gpu_backend = core::ffi::c_uint;
pub const bhs_gpu_buffer_usage_BHS_BUFFER_VERTEX: bhs_gpu_buffer_usage = 1;
pub const bhs_gpu_buffer_usage_BHS_BUFFER_INDEX: bhs_gpu_buffer_usage = 2;
pub const bhs_gpu_buffer_usage_BHS_BUFFER_UNIFORM: bhs_gpu_buffer_usage = 4;
pub const bhs_gpu_buffer_usage_BHS_BUFFER_STORAGE: bhs_gpu_buffer_usage = 8;
pub const bhs_gpu_buffer_usage_BHS_BUFFER_INDIRECT: bhs_gpu_buffer_usage = 16;
pub const bhs_gpu_buffer_usage_BHS_BUFFER_TRANSFER_SRC: bhs_gpu_buffer_usage = 32;
pub const bhs_gpu_buffer_usage_BHS_BUFFER_TRANSFER_DST: bhs_gpu_buffer_usage = 64;
pub type bhs_gpu_buffer_usage = core::ffi::c_uint;
pub const bhs_gpu_buffer_memory_BHS_MEMORY_GPU_ONLY: bhs_gpu_buffer_memory = 0;
pub const bhs_gpu_buffer_memory_BHS_MEMORY_CPU_VISIBLE: bhs_gpu_buffer_memory = 1;
pub const bhs_gpu_buffer_memory_BHS_MEMORY_CPU_TO_GPU: bhs_gpu_buffer_memory = 2;
pub const bhs_gpu_buffer_memory_BHS_MEMORY_GPU_TO_CPU: bhs_gpu_buffer_memory = 3;
pub type bhs_gpu_buffer_memory = core::ffi::c_uint;
pub const bhs_gpu_texture_format_BHS_FORMAT_UNDEFINED: bhs_gpu_texture_format = 0;
pub const bhs_gpu_texture_format_BHS_FORMAT_RGBA8_UNORM: bhs_gpu_texture_format = 1;
pub const bhs_gpu_texture_format_BHS_FORMAT_RGBA8_SRGB: bhs_gpu_texture_format = 2;
pub const bhs_gpu_texture_format_BHS_FORMAT_BGRA8_UNORM: bhs_gpu_texture_format = 3;
pub const bhs_gpu_texture_format_BHS_FORMAT_BGRA8_SRGB: bhs_gpu_texture_format = 4;
pub const bhs_gpu_texture_format_BHS_FORMAT_R32_FLOAT: bhs_gpu_texture_format = 5;
pub const bhs_gpu_texture_format_BHS_FORMAT_RG32_FLOAT: bhs_gpu_texture_format = 6;
pub const bhs_gpu_texture_format_BHS_FORMAT_RGB32_FLOAT: bhs_gpu_texture_format = 7;
pub const bhs_gpu_texture_format_BHS_FORMAT_RGBA32_FLOAT: bhs_gpu_texture_format = 8;
pub const bhs_gpu_texture_format_BHS_FORMAT_DEPTH32_FLOAT: bhs_gpu_texture_format = 9;
pub const bhs_gpu_texture_format_BHS_FORMAT_DEPTH24_STENCIL8: bhs_gpu_texture_format = 10;
pub type bhs_gpu_texture_format = core::ffi::c_uint;
pub const bhs_gpu_texture_usage_BHS_TEXTURE_SAMPLED: bhs_gpu_texture_usage = 1;
pub const bhs_gpu_texture_usage_BHS_TEXTURE_STORAGE: bhs_gpu_texture_usage = 2;
pub const bhs_gpu_texture_usage_BHS_TEXTURE_RENDER_TARGET: bhs_gpu_texture_usage = 4;
pub const bhs_gpu_texture_usage_BHS_TEXTURE_DEPTH_STENCIL: bhs_gpu_texture_usage = 8;
pub const bhs_gpu_texture_usage_BHS_TEXTURE_TRANSFER_SRC: bhs_gpu_texture_usage = 16;
pub const bhs_gpu_texture_usage_BHS_TEXTURE_TRANSFER_DST: bhs_gpu_texture_usage = 32;
pub type bhs_gpu_texture_usage = core::ffi::c_uint;
pub const bhs_gpu_shader_stage_BHS_SHADER_VERTEX: bhs_gpu_shader_stage = 0;
pub const bhs_gpu_shader_stage_BHS_SHADER_FRAGMENT: bhs_gpu_shader_stage = 1;
pub const bhs_gpu_shader_stage_BHS_SHADER_COMPUTE: bhs_gpu_shader_stage = 2;
pub type bhs_gpu_shader_stage = core::ffi::c_uint;
pub const bhs_gpu_primitive_BHS_PRIMITIVE_TRIANGLES: bhs_gpu_primitive = 0;
pub const bhs_gpu_primitive_BHS_PRIMITIVE_TRIANGLE_STRIP: bhs_gpu_primitive = 1;
pub const bhs_gpu_primitive_BHS_PRIMITIVE_LINES: bhs_gpu_primitive = 2;
pub const bhs_gpu_primitive_BHS_PRIMITIVE_LINE_STRIP: bhs_gpu_primitive = 3;
pub const bhs_gpu_primitive_BHS_PRIMITIVE_POINTS: bhs_gpu_primitive = 4;
pub type bhs_gpu_primitive = core::ffi::c_uint;
pub const bhs_gpu_cull_mode_BHS_CULL_NONE: bhs_gpu_cull_mode = 0;
pub const bhs_gpu_cull_mode_BHS_CULL_FRONT: bhs_gpu_cull_mode = 1;
pub const bhs_gpu_cull_mode_BHS_CULL_BACK: bhs_gpu_cull_mode = 2;
pub type bhs_gpu_cull_mode = core::ffi::c_uint;
pub const bhs_gpu_compare_func_BHS_COMPARE_NEVER: bhs_gpu_compare_func = 0;
pub const bhs_gpu_compare_func_BHS_COMPARE_LESS: bhs_gpu_compare_func = 1;
pub const bhs_gpu_compare_func_BHS_COMPARE_EQUAL: bhs_gpu_compare_func = 2;
pub const bhs_gpu_compare_func_BHS_COMPARE_LESS_EQUAL: bhs_gpu_compare_func = 3;
pub const bhs_gpu_compare_func_BHS_COMPARE_GREATER: bhs_gpu_compare_func = 4;
pub const bhs_gpu_compare_func_BHS_COMPARE_NOT_EQUAL: bhs_gpu_compare_func = 5;
pub const bhs_gpu_compare_func_BHS_COMPARE_GREATER_EQUAL: bhs_gpu_compare_func = 6;
pub const bhs_gpu_compare_func_BHS_COMPARE_ALWAYS: bhs_gpu_compare_func = 7;
pub type bhs_gpu_compare_func = core::ffi::c_uint;
pub const bhs_gpu_blend_factor_BHS_BLEND_ZERO: bhs_gpu_blend_factor = 0;
pub const bhs_gpu_blend_factor_BHS_BLEND_ONE: bhs_gpu_blend_factor = 1;
pub const bhs_gpu_blend_factor_BHS_BLEND_SRC_ALPHA: bhs_gpu_blend_factor = 2;
pub const bhs_gpu_blend_factor_BHS_BLEND_ONE_MINUS_SRC_ALPHA: bhs_gpu_blend_factor = 3;
pub const bhs_gpu_blend_factor_BHS_BLEND_DST_ALPHA: bhs_gpu_blend_factor = 4;
pub const bhs_gpu_blend_factor_BHS_BLEND_ONE_MINUS_DST_ALPHA: bhs_gpu_blend_factor = 5;
pub type bhs_gpu_blend_factor = core::ffi::c_uint;
pub const bhs_gpu_blend_op_BHS_BLEND_OP_ADD: bhs_gpu_blend_op = 0;
pub const bhs_gpu_blend_op_BHS_BLEND_OP_SUBTRACT: bhs_gpu_blend_op = 1;
pub const bhs_gpu_blend_op_BHS_BLEND_OP_MIN: bhs_gpu_blend_op = 2;
pub const bhs_gpu_blend_op_BHS_BLEND_OP_MAX: bhs_gpu_blend_op = 3;
pub type bhs_gpu_blend_op = core::ffi::c_uint;
pub const bhs_gpu_load_action_BHS_LOAD_DONT_CARE: bhs_gpu_load_action = 0;
pub const bhs_gpu_load_action_BHS_LOAD_LOAD: bhs_gpu_load_action = 1;
pub const bhs_gpu_load_action_BHS_LOAD_CLEAR: bhs_gpu_load_action = 2;
pub type bhs_gpu_load_action = core::ffi::c_uint;
pub const bhs_gpu_store_action_BHS_STORE_DONT_CARE: bhs_gpu_store_action = 0;
pub const bhs_gpu_store_action_BHS_STORE_STORE: bhs_gpu_store_action = 1;
pub type bhs_gpu_store_action = core::ffi::c_uint;
pub const bhs_gpu_filter_BHS_FILTER_NEAREST: bhs_gpu_filter = 0;
pub const bhs_gpu_filter_BHS_FILTER_LINEAR: bhs_gpu_filter = 1;
pub type bhs_gpu_filter = core::ffi::c_uint;
pub const bhs_gpu_address_mode_BHS_ADDRESS_REPEAT: bhs_gpu_address_mode = 0;
pub const bhs_gpu_address_mode_BHS_ADDRESS_CLAMP_TO_EDGE: bhs_gpu_address_mode = 1;
pub const bhs_gpu_address_mode_BHS_ADDRESS_CLAMP_TO_BORDER: bhs_gpu_address_mode = 2;
pub const bhs_gpu_address_mode_BHS_ADDRESS_MIRRORED_REPEAT: bhs_gpu_address_mode = 3;
pub type bhs_gpu_address_mode = core::ffi::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_gpu_device_config {
    pub preferred_backend: bhs_gpu_backend,
    pub enable_validation: bool,
    pub prefer_discrete_gpu: bool,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_gpu_buffer_config {
    pub size: u64,
    pub usage: u32,
    pub memory: bhs_gpu_buffer_memory,
    pub label: *const core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_gpu_texture_config {
    pub width: u32,
    pub height: u32,
    pub depth: u32,
    pub mip_levels: u32,
    pub array_layers: u32,
    pub format: bhs_gpu_texture_format,
    pub usage: u32,
    pub label: *const core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_gpu_sampler_config {
    pub min_filter: bhs_gpu_filter,
    pub mag_filter: bhs_gpu_filter,
    pub mip_filter: bhs_gpu_filter,
    pub address_u: bhs_gpu_address_mode,
    pub address_v: bhs_gpu_address_mode,
    pub address_w: bhs_gpu_address_mode,
    pub max_anisotropy: f32,
    pub compare_func: bhs_gpu_compare_func,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_gpu_shader_config {
    pub stage: bhs_gpu_shader_stage,
    pub code: *const core::ffi::c_void,
    pub code_size: usize,
    pub entry_point: *const core::ffi::c_char,
    pub label: *const core::ffi::c_char,
}
#[doc = " Descrição de atributo de vértice"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_gpu_vertex_attr {
    pub location: u32,
    pub binding: u32,
    pub format: bhs_gpu_texture_format,
    pub offset: u32,
}
#[doc = " Descrição de binding de vértice"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_gpu_vertex_binding {
    pub binding: u32,
    pub stride: u32,
    pub per_instance: bool,
}
#[doc = " Configuração de blending por render target"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_gpu_blend_state {
    pub enabled: bool,
    pub src_color: bhs_gpu_blend_factor,
    pub dst_color: bhs_gpu_blend_factor,
    pub color_op: bhs_gpu_blend_op,
    pub src_alpha: bhs_gpu_blend_factor,
    pub dst_alpha: bhs_gpu_blend_factor,
    pub alpha_op: bhs_gpu_blend_op,
}
#[doc = " Configuração do pipeline gráfico"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_gpu_pipeline_config {
    pub vertex_shader: bhs_gpu_shader_t,
    pub fragment_shader: bhs_gpu_shader_t,
    pub vertex_attrs: *const bhs_gpu_vertex_attr,
    pub vertex_attr_count: u32,
    pub vertex_bindings: *const bhs_gpu_vertex_binding,
    pub vertex_binding_count: u32,
    pub primitive: bhs_gpu_primitive,
    pub cull_mode: bhs_gpu_cull_mode,
    pub front_ccw: bool,
    pub depth_clip: bool,
    pub depth_test: bool,
    pub depth_write: bool,
    pub depth_compare: bhs_gpu_compare_func,
    pub blend_states: *const bhs_gpu_blend_state,
    pub blend_state_count: u32,
    pub color_formats: *const bhs_gpu_texture_format,
    pub color_format_count: u32,
    pub depth_format: bhs_gpu_texture_format,
    pub depth_stencil_format: bhs_gpu_texture_format,
    pub label: *const core::ffi::c_char,
}
#[doc = " Descrição de um render target"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_gpu_color_attachment {
    pub texture: bhs_gpu_texture_t,
    pub mip_level: u32,
    pub array_layer: u32,
    pub load_action: bhs_gpu_load_action,
    pub store_action: bhs_gpu_store_action,
    pub clear_color: [f32; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_gpu_depth_attachment {
    pub texture: bhs_gpu_texture_t,
    pub load_action: bhs_gpu_load_action,
    pub store_action: bhs_gpu_store_action,
    pub clear_depth: f32,
    pub clear_stencil: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_gpu_render_pass {
    pub color_attachments: *const bhs_gpu_color_attachment,
    pub color_attachment_count: u32,
    pub depth_attachment: *const bhs_gpu_depth_attachment,
}
#[doc = " Configuração do pipeline de computação"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_gpu_compute_pipeline_config {
    pub compute_shader: bhs_gpu_shader_t,
    pub label: *const core::ffi::c_char,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_gpu_swapchain_config {
    pub native_display: *mut core::ffi::c_void,
    pub native_window: *mut core::ffi::c_void,
    pub native_layer: *mut core::ffi::c_void,
    pub width: u32,
    pub height: u32,
    pub format: bhs_gpu_texture_format,
    pub buffer_count: u32,
    pub vsync: bool,
}
unsafe extern "C" {
    #[doc = " bhs_gpu_device_create - Cria device de renderização\n\n @config: Configuração do device\n @device: Ponteiro para receber o handle\n\n Retorna: BHS_GPU_OK ou código de erro"]
    pub fn bhs_gpu_device_create(
        config: *const bhs_gpu_device_config,
        device: *mut bhs_gpu_device_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn bhs_gpu_device_destroy(device: bhs_gpu_device_t);
}
unsafe extern "C" {
    #[doc = " bhs_gpu_device_get_backend - Retorna qual backend está em uso"]
    pub fn bhs_gpu_device_get_backend(device: bhs_gpu_device_t) -> bhs_gpu_backend;
}
unsafe extern "C" {
    #[doc = " bhs_gpu_device_get_name - Nome do device (ex: \"Apple M1\")"]
    pub fn bhs_gpu_device_get_name(device: bhs_gpu_device_t) -> *const core::ffi::c_char;
}
unsafe extern "C" {
    pub fn bhs_gpu_buffer_create(
        device: bhs_gpu_device_t,
        config: *const bhs_gpu_buffer_config,
        buffer: *mut bhs_gpu_buffer_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn bhs_gpu_buffer_destroy(buffer: bhs_gpu_buffer_t);
}
unsafe extern "C" {
    #[doc = " bhs_gpu_buffer_map - Mapeia buffer para CPU\n\n Apenas para buffers com BHS_MEMORY_CPU_VISIBLE ou similar.\n Retorna NULL em erro."]
    pub fn bhs_gpu_buffer_map(buffer: bhs_gpu_buffer_t) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    pub fn bhs_gpu_buffer_unmap(buffer: bhs_gpu_buffer_t);
}
unsafe extern "C" {
    #[doc = " bhs_gpu_buffer_upload - Upload de dados para buffer\n\n Conveniência para buffers que não são mapeáveis.\n Usa staging buffer internamente se necessário."]
    pub fn bhs_gpu_buffer_upload(
        buffer: bhs_gpu_buffer_t,
        offset: u64,
        data: *const core::ffi::c_void,
        size: u64,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn bhs_gpu_texture_create(
        device: bhs_gpu_device_t,
        config: *const bhs_gpu_texture_config,
        texture: *mut bhs_gpu_texture_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn bhs_gpu_texture_destroy(texture: bhs_gpu_texture_t);
}
unsafe extern "C" {
    pub fn bhs_gpu_texture_upload(
        texture: bhs_gpu_texture_t,
        mip_level: u32,
        array_layer: u32,
        data: *const core::ffi::c_void,
        size: usize,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn bhs_gpu_sampler_create(
        device: bhs_gpu_device_t,
        config: *const bhs_gpu_sampler_config,
        sampler: *mut bhs_gpu_sampler_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn bhs_gpu_sampler_destroy(sampler: bhs_gpu_sampler_t);
}
unsafe extern "C" {
    pub fn bhs_gpu_shader_create(
        device: bhs_gpu_device_t,
        config: *const bhs_gpu_shader_config,
        shader: *mut bhs_gpu_shader_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn bhs_gpu_shader_destroy(shader: bhs_gpu_shader_t);
}
unsafe extern "C" {
    pub fn bhs_gpu_pipeline_create(
        device: bhs_gpu_device_t,
        config: *const bhs_gpu_pipeline_config,
        pipeline: *mut bhs_gpu_pipeline_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn bhs_gpu_pipeline_destroy(pipeline: bhs_gpu_pipeline_t);
}
unsafe extern "C" {
    pub fn bhs_gpu_pipeline_compute_create(
        device: bhs_gpu_device_t,
        config: *const bhs_gpu_compute_pipeline_config,
        pipeline: *mut bhs_gpu_pipeline_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn bhs_gpu_swapchain_create(
        device: bhs_gpu_device_t,
        config: *const bhs_gpu_swapchain_config,
        swapchain: *mut bhs_gpu_swapchain_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn bhs_gpu_swapchain_submit(
        swapchain: bhs_gpu_swapchain_t,
        cmd: bhs_gpu_cmd_buffer_t,
        fence: bhs_gpu_fence_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " bhs_gpu_swapchain_present - Apresenta frame atual"]
    pub fn bhs_gpu_swapchain_present(swapchain: bhs_gpu_swapchain_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn bhs_gpu_swapchain_destroy(swapchain: bhs_gpu_swapchain_t);
}
unsafe extern "C" {
    #[doc = " bhs_gpu_swapchain_resize - Redimensiona swapchain\n\n Chamado após resize da janela."]
    pub fn bhs_gpu_swapchain_resize(
        swapchain: bhs_gpu_swapchain_t,
        width: u32,
        height: u32,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " bhs_gpu_swapchain_next_texture - Obtém próxima textura para desenhar\n\n @swapchain: Handle do swapchain\n @texture: Ponteiro para receber textura (NÃO destruir - pertence ao\n swapchain)\n\n Retorna: BHS_GPU_OK, ou BHS_GPU_ERR_SWAPCHAIN se precisar recriar"]
    pub fn bhs_gpu_swapchain_next_texture(
        swapchain: bhs_gpu_swapchain_t,
        texture: *mut bhs_gpu_texture_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " bhs_gpu_cmd_buffer_create - Cria command buffer\n\n Command buffers são reutilizáveis após reset."]
    pub fn bhs_gpu_cmd_buffer_create(
        device: bhs_gpu_device_t,
        cmd: *mut bhs_gpu_cmd_buffer_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn bhs_gpu_cmd_buffer_destroy(cmd: bhs_gpu_cmd_buffer_t);
}
unsafe extern "C" {
    #[doc = " bhs_gpu_cmd_begin - Inicia gravação de comandos"]
    pub fn bhs_gpu_cmd_begin(cmd: bhs_gpu_cmd_buffer_t);
}
unsafe extern "C" {
    pub fn bhs_gpu_cmd_end(cmd: bhs_gpu_cmd_buffer_t);
}
unsafe extern "C" {
    #[doc = " bhs_gpu_cmd_reset - Limpa comandos para reutilização"]
    pub fn bhs_gpu_cmd_reset(cmd: bhs_gpu_cmd_buffer_t);
}
unsafe extern "C" {
    pub fn bhs_gpu_cmd_begin_render_pass(
        cmd: bhs_gpu_cmd_buffer_t,
        pass: *const bhs_gpu_render_pass,
    );
}
unsafe extern "C" {
    pub fn bhs_gpu_cmd_end_render_pass(cmd: bhs_gpu_cmd_buffer_t);
}
unsafe extern "C" {
    pub fn bhs_gpu_cmd_set_pipeline(cmd: bhs_gpu_cmd_buffer_t, pipeline: bhs_gpu_pipeline_t);
}
unsafe extern "C" {
    pub fn bhs_gpu_cmd_set_viewport(
        cmd: bhs_gpu_cmd_buffer_t,
        x: f32,
        y: f32,
        width: f32,
        height: f32,
        min_depth: f32,
        max_depth: f32,
    );
}
unsafe extern "C" {
    pub fn bhs_gpu_cmd_set_scissor(
        cmd: bhs_gpu_cmd_buffer_t,
        x: i32,
        y: i32,
        width: u32,
        height: u32,
    );
}
unsafe extern "C" {
    pub fn bhs_gpu_cmd_set_vertex_buffer(
        cmd: bhs_gpu_cmd_buffer_t,
        binding: u32,
        buffer: bhs_gpu_buffer_t,
        offset: u64,
    );
}
unsafe extern "C" {
    pub fn bhs_gpu_cmd_set_index_buffer(
        cmd: bhs_gpu_cmd_buffer_t,
        buffer: bhs_gpu_buffer_t,
        offset: u64,
        is_32bit: bool,
    );
}
unsafe extern "C" {
    pub fn bhs_gpu_cmd_push_constants(
        cmd: bhs_gpu_cmd_buffer_t,
        offset: u32,
        data: *const core::ffi::c_void,
        size: u32,
    );
}
unsafe extern "C" {
    #[doc = " bhs_gpu_cmd_bind_texture - Binda textura e sampler num binding point\n\n Abstração simplificada de descriptors.\n @set: Índice do Descriptor Set (geralmente 0 ou 1)\n @binding: Índice do binding dentro do set"]
    pub fn bhs_gpu_cmd_bind_texture(
        cmd: bhs_gpu_cmd_buffer_t,
        set: u32,
        binding: u32,
        texture: bhs_gpu_texture_t,
        sampler: bhs_gpu_sampler_t,
    );
}
unsafe extern "C" {
    pub fn bhs_gpu_cmd_draw(
        cmd: bhs_gpu_cmd_buffer_t,
        vertex_count: u32,
        instance_count: u32,
        first_vertex: u32,
        first_instance: u32,
    );
}
unsafe extern "C" {
    pub fn bhs_gpu_cmd_draw_indexed(
        cmd: bhs_gpu_cmd_buffer_t,
        index_count: u32,
        instance_count: u32,
        first_index: u32,
        vertex_offset: i32,
        first_instance: u32,
    );
}
unsafe extern "C" {
    pub fn bhs_gpu_cmd_dispatch(
        cmd: bhs_gpu_cmd_buffer_t,
        group_count_x: u32,
        group_count_y: u32,
        group_count_z: u32,
    );
}
unsafe extern "C" {
    #[doc = " bhs_gpu_cmd_transition_texture - Transição de layout de imagem\n\n Útil para sincronizar escrita de Compute com leitura de Fragment."]
    pub fn bhs_gpu_cmd_transition_texture(cmd: bhs_gpu_cmd_buffer_t, texture: bhs_gpu_texture_t);
}
unsafe extern "C" {
    #[doc = " bhs_gpu_cmd_bind_compute_storage_texture - Bind de storage image para compute"]
    pub fn bhs_gpu_cmd_bind_compute_storage_texture(
        cmd: bhs_gpu_cmd_buffer_t,
        pipeline: bhs_gpu_pipeline_t,
        set: u32,
        binding: u32,
        texture: bhs_gpu_texture_t,
    );
}
unsafe extern "C" {
    pub fn bhs_gpu_fence_create(
        device: bhs_gpu_device_t,
        fence: *mut bhs_gpu_fence_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn bhs_gpu_fence_destroy(fence: bhs_gpu_fence_t);
}
unsafe extern "C" {
    #[doc = " bhs_gpu_fence_wait - Aguarda fence ser sinalizada\n\n @fence: Handle do fence\n @timeout_ns: Timeout em nanosegundos (0 = não espera, UINT64_MAX = infinito)\n\n Retorna: BHS_GPU_OK se sinalizado, BHS_GPU_ERR_TIMEOUT se expirou"]
    pub fn bhs_gpu_fence_wait(fence: bhs_gpu_fence_t, timeout_ns: u64) -> core::ffi::c_int;
}
unsafe extern "C" {
    pub fn bhs_gpu_fence_reset(fence: bhs_gpu_fence_t);
}
unsafe extern "C" {
    #[doc = " bhs_gpu_submit - Submete command buffer para execução\n\n @device: Device\n @cmd: Command buffer a submeter\n @signal_fence: Fence a sinalizar quando completar (pode ser NULL)"]
    pub fn bhs_gpu_submit(
        device: bhs_gpu_device_t,
        cmd: bhs_gpu_cmd_buffer_t,
        signal_fence: bhs_gpu_fence_t,
    ) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " bhs_gpu_wait_idle - Aguarda GPU terminar todo trabalho\n\n Bloqueia até que todos os command buffers submetidos completem."]
    pub fn bhs_gpu_wait_idle(device: bhs_gpu_device_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_ui_ctx_impl {
    _unused: [u8; 0],
}
#[doc = " Contexto UI - o grande chefão que gerencia tudo.\n\n Internamente tem: platform, window, gpu device, swapchain, input state,\n widget state, render batch... basicamente a cozinha inteira."]
pub type bhs_ui_ctx_t = *mut bhs_ui_ctx_impl;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_font_atlas_impl {
    _unused: [u8; 0],
}
#[doc = " Handle para Atlas de Fontes (Texture + Glyphs)"]
pub type bhs_font_atlas_t = *mut bhs_font_atlas_impl;
pub const bhs_ui_error_BHS_UI_OK: bhs_ui_error = 0;
pub const bhs_ui_error_BHS_UI_SKIP: bhs_ui_error = 1;
pub const bhs_ui_error_BHS_UI_ERR_NOMEM: bhs_ui_error = -1;
pub const bhs_ui_error_BHS_UI_ERR_INIT: bhs_ui_error = -2;
pub const bhs_ui_error_BHS_UI_ERR_WINDOW: bhs_ui_error = -3;
pub const bhs_ui_error_BHS_UI_ERR_GPU: bhs_ui_error = -4;
pub const bhs_ui_error_BHS_UI_ERR_INVALID: bhs_ui_error = -5;
pub type bhs_ui_error = core::ffi::c_int;
#[doc = " Configuração para criar o contexto UI.\n\n Basicamente: \"que janela você quer?\""]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_ui_config {
    pub title: *const core::ffi::c_char,
    pub width: i32,
    pub height: i32,
    pub resizable: bool,
    pub vsync: bool,
    pub debug: bool,
}
#[doc = " Cor RGBA normalizada (0.0 - 1.0).\n\n Por que float? Porque é o século 21 e 8 bits por canal é coisa de 1995."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_ui_color {
    pub r: f32,
    pub g: f32,
    pub b: f32,
    pub a: f32,
}
#[doc = " Retângulo com posição e tamanho.\n\n Coordenadas: (0,0) é canto superior esquerdo. Y cresce pra baixo.\n Sim, igual HTML. Não, não foi minha escolha."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_ui_rect {
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
}
unsafe extern "C" {
    #[doc = " bhs_ui_create - Cria contexto UI com janela e tudo mais\n\n Isso aqui faz MUITA coisa por baixo:\n 1. Inicializa platform (Wayland/Cocoa/Win32)\n 2. Cria janela\n 3. Inicializa GPU (Vulkan/Metal/DX)\n 4. Cria swapchain\n 5. Prepara sistema de input\n 6. Inicializa batching de widgets\n\n Se qualquer etapa falhar, limpa tudo e retorna erro.\n Tipo um foguete: ou decola perfeito ou explode espetacularmente.\n\n @config: Configuração da janela\n @ctx: Ponteiro para receber o contexto\n\n Retorna: BHS_UI_OK ou código de erro"]
    pub fn bhs_ui_create(config: *const bhs_ui_config, ctx: *mut bhs_ui_ctx_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " bhs_ui_destroy - Destrói contexto e libera tudo\n\n Faz o cleanup na ordem inversa da criação.\n Depois disso, @ctx é inválido. Não usa mais."]
    pub fn bhs_ui_destroy(ctx: bhs_ui_ctx_t);
}
unsafe extern "C" {
    pub fn bhs_ui_quit(ctx: bhs_ui_ctx_t);
}
unsafe extern "C" {
    #[doc = " bhs_ui_should_close - Verifica se deve fechar\n\n Retorna true se o usuário clicou no X ou pressionou Alt+F4.\n Use no loop: while (!bhs_ui_should_close(ctx)) { ... }"]
    pub fn bhs_ui_should_close(ctx: bhs_ui_ctx_t) -> bool;
}
unsafe extern "C" {
    #[doc = " bhs_ui_set_vsync - Habilita/Desabilita VSync em tempo de execução\n Requer recriar o swapchain, que ocorrerá no próximo frame."]
    pub fn bhs_ui_set_vsync(ctx: bhs_ui_ctx_t, enabled: bool);
}
unsafe extern "C" {
    #[doc = " bhs_ui_begin_frame - Inicia um frame\n\n Faz poll de eventos, atualiza input state, prepara batching.\n DEVE ser chamado antes de qualquer widget ou desenho.\n\n Retorna: BHS_UI_OK ou BHS_UI_ERR_* se swapchain morreu"]
    pub fn bhs_ui_begin_frame(ctx: bhs_ui_ctx_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " bhs_ui_end_frame - Finaliza e apresenta frame\n\n Submete todos os comandos de desenho e faz present.\n DEVE ser chamado após todos os widgets."]
    pub fn bhs_ui_end_frame(ctx: bhs_ui_ctx_t) -> core::ffi::c_int;
}
unsafe extern "C" {
    #[doc = " bhs_ui_get_size - Obtém tamanho da janela"]
    pub fn bhs_ui_get_size(ctx: bhs_ui_ctx_t, width: *mut i32, height: *mut i32);
}
unsafe extern "C" {
    #[doc = " bhs_ui_cmd_begin - Inicia gravação do command buffer (Reset + Begin)\n Deve ser chamado antes de qualquer operação de GPU no frame."]
    pub fn bhs_ui_cmd_begin(ctx: bhs_ui_ctx_t);
}
unsafe extern "C" {
    pub fn bhs_ui_get_gpu_device(ctx: bhs_ui_ctx_t) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = " bhs_ui_get_current_cmd - Obtém o buffer de comando atual (void* casting\n necessario)\n\n Útil para injetar comandos customizados (compute, transfer) antes da\n renderização."]
    pub fn bhs_ui_get_current_cmd(ctx: bhs_ui_ctx_t) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = " bhs_ui_flush - Força o envio do batch atual para a GPU\n Útil antes de mudar o pipeline manualmente."]
    pub fn bhs_ui_flush(ctx: bhs_ui_ctx_t);
}
unsafe extern "C" {
    #[doc = " bhs_ui_reset_render_state - Restaura o pipeline e estado da UI\n Útil após desenhar coisas customizadas que alteram o pipeline."]
    pub fn bhs_ui_reset_render_state(ctx: bhs_ui_ctx_t);
}
unsafe extern "C" {
    #[doc = " bhs_ui_begin_drawing - Inicia explicitamente o Render Pass\n\n Se você usar isso, bhs_ui_begin_frame NÃO iniciará o render pass\n automaticamente. Isso permite rodar Compute Shaders antes de desenhar."]
    pub fn bhs_ui_begin_drawing(ctx: bhs_ui_ctx_t);
}
unsafe extern "C" {
    #[doc = " bhs_ui_key_down - Tecla está pressionada agora?"]
    pub fn bhs_ui_key_down(ctx: bhs_ui_ctx_t, keycode: u32) -> bool;
}
unsafe extern "C" {
    #[doc = " bhs_ui_key_pressed - Tecla foi pressionada NESTE frame?\n\n Diferente de key_down: só retorna true uma vez por pressionamento."]
    pub fn bhs_ui_key_pressed(ctx: bhs_ui_ctx_t, keycode: u32) -> bool;
}
unsafe extern "C" {
    #[doc = " bhs_ui_mouse_pos - Posição atual do mouse"]
    pub fn bhs_ui_mouse_pos(ctx: bhs_ui_ctx_t, x: *mut i32, y: *mut i32);
}
unsafe extern "C" {
    #[doc = " bhs_ui_mouse_down - Botão do mouse está pressionado?"]
    pub fn bhs_ui_mouse_down(ctx: bhs_ui_ctx_t, button: core::ffi::c_int) -> bool;
}
unsafe extern "C" {
    #[doc = " bhs_ui_mouse_clicked - Botão foi clicado NESTE frame?"]
    pub fn bhs_ui_mouse_clicked(ctx: bhs_ui_ctx_t, button: core::ffi::c_int) -> bool;
}
unsafe extern "C" {
    #[doc = " bhs_ui_mouse_scroll - Obtém delta do scroll vertical NESTE frame"]
    pub fn bhs_ui_mouse_scroll(ctx: bhs_ui_ctx_t) -> f32;
}
unsafe extern "C" {
    #[doc = " bhs_ui_clear - Limpa tela com cor"]
    pub fn bhs_ui_clear(ctx: bhs_ui_ctx_t, color: bhs_ui_color);
}
unsafe extern "C" {
    #[doc = " bhs_ui_draw_rect - Desenha retângulo preenchido"]
    pub fn bhs_ui_draw_rect(ctx: bhs_ui_ctx_t, rect: bhs_ui_rect, color: bhs_ui_color);
}
unsafe extern "C" {
    #[doc = " bhs_ui_draw_rect_outline - Desenha borda de retângulo"]
    pub fn bhs_ui_draw_rect_outline(
        ctx: bhs_ui_ctx_t,
        rect: bhs_ui_rect,
        color: bhs_ui_color,
        thickness: f32,
    );
}
unsafe extern "C" {
    #[doc = " bhs_ui_draw_line - Desenha uma linha entre dois pontos\n\n Implementada como um quad rotacionado para permitir espessura controlada."]
    pub fn bhs_ui_draw_line(
        ctx: bhs_ui_ctx_t,
        x1: f32,
        y1: f32,
        x2: f32,
        y2: f32,
        color: bhs_ui_color,
        thickness: f32,
    );
}
unsafe extern "C" {
    #[doc = " bhs_ui_draw_circle_fill - Desenha um círculo preenchido\n\n Aproximação por polígono (Triangle Fan)."]
    pub fn bhs_ui_draw_circle_fill(
        ctx: bhs_ui_ctx_t,
        cx: f32,
        cy: f32,
        radius: f32,
        color: bhs_ui_color,
    );
}
unsafe extern "C" {
    #[doc = " bhs_ui_draw_text - Desenha texto\n\n Fonte: monospace builtin. Não pergunta, só aceita."]
    pub fn bhs_ui_draw_text(
        ctx: bhs_ui_ctx_t,
        text: *const core::ffi::c_char,
        x: f32,
        y: f32,
        size: f32,
        color: bhs_ui_color,
    );
}
unsafe extern "C" {
    #[doc = " @brief Mede as dimensões de um texto com o sistema de fontes atual"]
    pub fn bhs_ui_measure_text(ctx: bhs_ui_ctx_t, text: *const core::ffi::c_char, size: f32)
        -> f32;
}
unsafe extern "C" {
    #[doc = " bhs_ui_draw_texture - Desenha textura (quad texturizado)\n\n Fundamental para o Viewport do simulador.\n @texture: Se NULL, desenha retângulo branco (equivalente a draw_rect)"]
    pub fn bhs_ui_draw_texture(
        ctx: bhs_ui_ctx_t,
        texture: *mut core::ffi::c_void,
        x: f32,
        y: f32,
        w: f32,
        h: f32,
        color: bhs_ui_color,
    );
}
unsafe extern "C" {
    #[doc = " @brief Desenha textura com coordenadas UV controladas\n Permite scrolling, tiling e atlas."]
    pub fn bhs_ui_draw_texture_uv(
        ctx: bhs_ui_ctx_t,
        texture: *mut core::ffi::c_void,
        x: f32,
        y: f32,
        w: f32,
        h: f32,
        u0: f32,
        v0: f32,
        u1: f32,
        v1: f32,
        color: bhs_ui_color,
    );
}
unsafe extern "C" {
    #[doc = " @brief Cria uma textura a partir de dados RGBA em memória.\n @param width Largura da imagem\n @param height Altura da imagem\n @param data Ponteiro para dados RGBA (uint8_t), row-major.\n @return Handle opaco da textura ou NULL em erro."]
    pub fn bhs_ui_create_texture_from_rgba(
        ctx: bhs_ui_ctx_t,
        width: core::ffi::c_int,
        height: core::ffi::c_int,
        data: *const core::ffi::c_void,
    ) -> *mut core::ffi::c_void;
}
unsafe extern "C" {
    #[doc = " @brief Desenha um quad com UVs arbitrários para cada vértice (TL, TR, BR, BL)\n Essencial para distorções complexas (esferas, etc)."]
    pub fn bhs_ui_draw_quad_uv(
        ctx: bhs_ui_ctx_t,
        texture: *mut core::ffi::c_void,
        x0: f32,
        y0: f32,
        u0: f32,
        v0: f32,
        x1: f32,
        y1: f32,
        u1: f32,
        v1: f32,
        x2: f32,
        y2: f32,
        u2: f32,
        v2: f32,
        x3: f32,
        y3: f32,
        u3: f32,
        v3: f32,
        color: bhs_ui_color,
    );
}
pub const bhs_ui_icon_BHS_ICON_NONE: bhs_ui_icon = 0;
pub const bhs_ui_icon_BHS_ICON_GEAR: bhs_ui_icon = 1;
pub const bhs_ui_icon_BHS_ICON_PHYSICS: bhs_ui_icon = 2;
pub const bhs_ui_icon_BHS_ICON_CAMERA: bhs_ui_icon = 3;
pub const bhs_ui_icon_BHS_ICON_INFO: bhs_ui_icon = 4;
pub const bhs_ui_icon_BHS_ICON_CLOSE: bhs_ui_icon = 5;
pub type bhs_ui_icon = core::ffi::c_uint;
unsafe extern "C" {
    #[doc = " bhs_ui_button - Desenha botão e retorna se foi clicado\n\n Immediate mode: chama todo frame, retorna true quando clicado."]
    pub fn bhs_ui_button(
        ctx: bhs_ui_ctx_t,
        label: *const core::ffi::c_char,
        rect: bhs_ui_rect,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " bhs_ui_icon_button - Botão circular com ícone\n\n Ideal para controles flutuantes no canto da tela.\n Retorna true se clicado."]
    pub fn bhs_ui_icon_button(
        ctx: bhs_ui_ctx_t,
        icon: bhs_ui_icon,
        x: f32,
        y: f32,
        size: f32,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " bhs_ui_label - Desenha label (texto estático)"]
    pub fn bhs_ui_label(ctx: bhs_ui_ctx_t, text: *const core::ffi::c_char, x: f32, y: f32);
}
unsafe extern "C" {
    #[doc = " bhs_ui_panel - Desenha painel (background + borda)\n\n Use pra agrupar widgets visualmente."]
    pub fn bhs_ui_panel(
        ctx: bhs_ui_ctx_t,
        rect: bhs_ui_rect,
        bg: bhs_ui_color,
        border: bhs_ui_color,
    );
}
unsafe extern "C" {
    #[doc = " bhs_ui_panel_begin - Inicia um painel modal centralizado\n\n Cria um overlay escurecido sobre a tela e centraliza uma janela.\n Use bhs_ui_panel_end() para fechar o escopo."]
    pub fn bhs_ui_panel_begin(
        ctx: bhs_ui_ctx_t,
        title: *const core::ffi::c_char,
        width: f32,
        height: f32,
    );
}
unsafe extern "C" {
    #[doc = " bhs_ui_panel_end - Finaliza o painel modal"]
    pub fn bhs_ui_panel_end(ctx: bhs_ui_ctx_t);
}
unsafe extern "C" {
    #[doc = " bhs_ui_slider - Slider horizontal"]
    pub fn bhs_ui_slider(ctx: bhs_ui_ctx_t, rect: bhs_ui_rect, value: *mut f32) -> bool;
}
unsafe extern "C" {
    #[doc = " bhs_ui_checkbox - Checkbox"]
    pub fn bhs_ui_checkbox(
        ctx: bhs_ui_ctx_t,
        label: *const core::ffi::c_char,
        rect: bhs_ui_rect,
        checked: *mut bool,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " bhs_ui_text_field - Campo de Texto\n\n @focused: Estado de foco gerido externamente (ou internamente se NULL)\n Returns true se o texto mudou."]
    pub fn bhs_ui_text_field(
        ctx: bhs_ui_ctx_t,
        rect: bhs_ui_rect,
        buf: *mut core::ffi::c_char,
        max_len: usize,
        focused: *mut bool,
    ) -> bool;
}
pub const bhs_ui_key_BHS_KEY_ESCAPE: bhs_ui_key = 1;
pub const bhs_ui_key_BHS_KEY_1: bhs_ui_key = 2;
pub const bhs_ui_key_BHS_KEY_2: bhs_ui_key = 3;
pub const bhs_ui_key_BHS_KEY_3: bhs_ui_key = 4;
pub const bhs_ui_key_BHS_KEY_4: bhs_ui_key = 5;
pub const bhs_ui_key_BHS_KEY_5: bhs_ui_key = 6;
pub const bhs_ui_key_BHS_KEY_6: bhs_ui_key = 7;
pub const bhs_ui_key_BHS_KEY_7: bhs_ui_key = 8;
pub const bhs_ui_key_BHS_KEY_8: bhs_ui_key = 9;
pub const bhs_ui_key_BHS_KEY_9: bhs_ui_key = 10;
pub const bhs_ui_key_BHS_KEY_0: bhs_ui_key = 11;
pub const bhs_ui_key_BHS_KEY_Q: bhs_ui_key = 16;
pub const bhs_ui_key_BHS_KEY_W: bhs_ui_key = 17;
pub const bhs_ui_key_BHS_KEY_E: bhs_ui_key = 18;
pub const bhs_ui_key_BHS_KEY_R: bhs_ui_key = 19;
pub const bhs_ui_key_BHS_KEY_T: bhs_ui_key = 20;
pub const bhs_ui_key_BHS_KEY_Y: bhs_ui_key = 21;
pub const bhs_ui_key_BHS_KEY_U: bhs_ui_key = 22;
pub const bhs_ui_key_BHS_KEY_I: bhs_ui_key = 23;
pub const bhs_ui_key_BHS_KEY_O: bhs_ui_key = 24;
pub const bhs_ui_key_BHS_KEY_P: bhs_ui_key = 25;
pub const bhs_ui_key_BHS_KEY_A: bhs_ui_key = 30;
pub const bhs_ui_key_BHS_KEY_S: bhs_ui_key = 31;
pub const bhs_ui_key_BHS_KEY_D: bhs_ui_key = 32;
pub const bhs_ui_key_BHS_KEY_F: bhs_ui_key = 33;
pub const bhs_ui_key_BHS_KEY_G: bhs_ui_key = 34;
pub const bhs_ui_key_BHS_KEY_H: bhs_ui_key = 35;
pub const bhs_ui_key_BHS_KEY_J: bhs_ui_key = 36;
pub const bhs_ui_key_BHS_KEY_K: bhs_ui_key = 37;
pub const bhs_ui_key_BHS_KEY_L: bhs_ui_key = 38;
pub const bhs_ui_key_BHS_KEY_Z: bhs_ui_key = 44;
pub const bhs_ui_key_BHS_KEY_X: bhs_ui_key = 45;
pub const bhs_ui_key_BHS_KEY_C: bhs_ui_key = 46;
pub const bhs_ui_key_BHS_KEY_V: bhs_ui_key = 47;
pub const bhs_ui_key_BHS_KEY_B: bhs_ui_key = 48;
pub const bhs_ui_key_BHS_KEY_N: bhs_ui_key = 49;
pub const bhs_ui_key_BHS_KEY_M: bhs_ui_key = 50;
pub const bhs_ui_key_BHS_KEY_SPACE: bhs_ui_key = 57;
pub const bhs_ui_key_BHS_KEY_ENTER: bhs_ui_key = 28;
pub const bhs_ui_key_BHS_KEY_UP: bhs_ui_key = 103;
pub const bhs_ui_key_BHS_KEY_DOWN: bhs_ui_key = 108;
pub const bhs_ui_key_BHS_KEY_LEFT: bhs_ui_key = 105;
pub const bhs_ui_key_BHS_KEY_RIGHT: bhs_ui_key = 106;
pub const bhs_ui_key_BHS_KEY_LEFTSHIFT: bhs_ui_key = 42;
pub const bhs_ui_key_BHS_KEY_RIGHTSHIFT: bhs_ui_key = 54;
pub type bhs_ui_key = core::ffi::c_uint;
pub const bhs_layout_dir_t_BHS_LAYOUT_ROW: bhs_layout_dir_t = 0;
pub const bhs_layout_dir_t_BHS_LAYOUT_COLUMN: bhs_layout_dir_t = 1;
pub type bhs_layout_dir_t = core::ffi::c_uint;
pub const bhs_align_t_BHS_ALIGN_START: bhs_align_t = 0;
pub const bhs_align_t_BHS_ALIGN_CENTER: bhs_align_t = 1;
pub const bhs_align_t_BHS_ALIGN_END: bhs_align_t = 2;
pub const bhs_align_t_BHS_ALIGN_STRETCH: bhs_align_t = 3;
pub type bhs_align_t = core::ffi::c_uint;
pub const bhs_justify_t_BHS_JUSTIFY_START: bhs_justify_t = 0;
pub const bhs_justify_t_BHS_JUSTIFY_CENTER: bhs_justify_t = 1;
pub const bhs_justify_t_BHS_JUSTIFY_END: bhs_justify_t = 2;
pub const bhs_justify_t_BHS_JUSTIFY_SPACE_BETWEEN: bhs_justify_t = 3;
pub const bhs_justify_t_BHS_JUSTIFY_SPACE_AROUND: bhs_justify_t = 4;
pub type bhs_justify_t = core::ffi::c_uint;
#[doc = " Configuração de estilo de layout."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_layout_style {
    pub width: f32,
    pub height: f32,
    pub padding: [f32; 4usize],
    pub margin: [f32; 4usize],
    pub gap: f32,
    pub align_items: bhs_align_t,
    pub justify_content: bhs_justify_t,
    pub flex_grow: f32,
}
unsafe extern "C" {
    #[doc = " bhs_layout_begin - Inicia um container de layout\n\n @dir: Direção (ROW ou COLUMN)\n @style: Estilo do container\n @rect: Retângulo disponível (se NULL, usa o pai ou janela inteira)"]
    pub fn bhs_layout_begin(
        ctx: bhs_ui_ctx_t,
        dir: bhs_layout_dir_t,
        style: *const bhs_layout_style,
    );
}
unsafe extern "C" {
    #[doc = " bhs_layout_end - Fecha o container atual"]
    pub fn bhs_layout_end(ctx: bhs_ui_ctx_t);
}
unsafe extern "C" {
    #[doc = " bhs_layout_next - Obtém o retângulo para o próximo item\n\n Calcula onde o próximo widget deve ficar baseado no layout atual."]
    pub fn bhs_layout_next(ctx: bhs_ui_ctx_t, width: f32, height: f32) -> bhs_ui_rect;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_theme_colors {
    pub background: bhs_ui_color,
    pub surface: bhs_ui_color,
    pub primary: bhs_ui_color,
    pub secondary: bhs_ui_color,
    pub text: bhs_ui_color,
    pub text_dim: bhs_ui_color,
    pub border: bhs_ui_color,
    pub error: bhs_ui_color,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bhs_theme {
    pub colors: bhs_theme_colors,
    pub border_radius: f32,
    pub border_width: f32,
    pub font_size_base: f32,
}
unsafe extern "C" {
    #[doc = " bhs_theme_get_default - Retorna o tema padrão (Dark/Dracula-ish)"]
    pub fn bhs_theme_get_default() -> *const bhs_theme;
}
pub const bhs_log_level_BHS_LOG_LEVEL_TRACE: bhs_log_level = 0;
pub const bhs_log_level_BHS_LOG_LEVEL_DEBUG: bhs_log_level = 1;
pub const bhs_log_level_BHS_LOG_LEVEL_INFO: bhs_log_level = 2;
pub const bhs_log_level_BHS_LOG_LEVEL_WARN: bhs_log_level = 3;
pub const bhs_log_level_BHS_LOG_LEVEL_ERROR: bhs_log_level = 4;
pub const bhs_log_level_BHS_LOG_LEVEL_FATAL: bhs_log_level = 5;
pub type bhs_log_level = core::ffi::c_uint;
pub const bhs_log_channel_BHS_LOG_CHANNEL_CORE: bhs_log_channel = 1;
pub const bhs_log_channel_BHS_LOG_CHANNEL_PLATFORM: bhs_log_channel = 2;
pub const bhs_log_channel_BHS_LOG_CHANNEL_RENDER: bhs_log_channel = 4;
pub const bhs_log_channel_BHS_LOG_CHANNEL_UI: bhs_log_channel = 8;
pub const bhs_log_channel_BHS_LOG_CHANNEL_PHYSICS: bhs_log_channel = 16;
pub const bhs_log_channel_BHS_LOG_CHANNEL_ECS: bhs_log_channel = 32;
pub const bhs_log_channel_BHS_LOG_CHANNEL_SCENE: bhs_log_channel = 64;
pub const bhs_log_channel_BHS_LOG_CHANNEL_ASSETS: bhs_log_channel = 128;
pub type bhs_log_channel = core::ffi::c_uint;
unsafe extern "C" {
    #[doc = " bhs_log_init - Inicializa o sistema de logs\n\n Chame isso antes de qualquer log. Configura mutex interno."]
    pub fn bhs_log_init();
}
unsafe extern "C" {
    #[doc = " bhs_log_shutdown - Finaliza o sistema de logs\n\n Libera recursos. Flush de buffers."]
    pub fn bhs_log_shutdown();
}
unsafe extern "C" {
    #[doc = " bhs_log_set_level - Define nível mínimo de log\n @level: Logs abaixo desse nível são ignorados\n\n Padrão: BHS_LOG_LEVEL_INFO em Release, BHS_LOG_LEVEL_TRACE em Debug."]
    pub fn bhs_log_set_level(level: bhs_log_level);
}
unsafe extern "C" {
    #[doc = " bhs_log_set_channels - Define quais canais estão ativos\n @channels: Bitmask de canais (ex: BHS_LOG_CHANNEL_PHYSICS | BHS_LOG_CHANNEL_RENDER)\n\n Padrão: BHS_LOG_CHANNEL_ALL"]
    pub fn bhs_log_set_channels(channels: u32);
}
unsafe extern "C" {
    #[doc = " bhs_log_set_file - Redireciona logs para arquivo\n @path: Caminho do arquivo (NULL = só stdout)\n\n Logs vão para stdout E arquivo simultaneamente."]
    pub fn bhs_log_set_file(path: *const core::ffi::c_char);
}
unsafe extern "C" {
    #[doc = " bhs_log_set_colors - Habilita/desabilita cores ANSI\n @enabled: true = cores, false = texto puro"]
    pub fn bhs_log_set_colors(enabled: bool);
}
unsafe extern "C" {
    pub fn bhs_log_output(
        level: bhs_log_level,
        channel: bhs_log_channel,
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
        fmt: *const core::ffi::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn bhs_log_output_v(
        level: bhs_log_level,
        channel: bhs_log_channel,
        file: *const core::ffi::c_char,
        line: core::ffi::c_int,
        fmt: *const core::ffi::c_char,
        args: *mut __va_list_tag,
    );
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: core::ffi::c_uint,
    pub fp_offset: core::ffi::c_uint,
    pub overflow_arg_area: *mut core::ffi::c_void,
    pub reg_save_area: *mut core::ffi::c_void,
}
