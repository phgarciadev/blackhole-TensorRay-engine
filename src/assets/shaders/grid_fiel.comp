#version 450

/**
 * @file grid_fiel.comp
 * @brief Shader modular focado em fidelidade visual (Imagem Benchmark 2)
 */

layout(local_size_x = 16, local_size_y = 16) in;
layout(set = 0, binding = 0, rgba8) uniform writeonly image2D output_image;

layout(push_constant) uniform PushConstants {
    float time;
    vec2 resolution;
    float camera_pitch;  /* Ângulo de inclinação */
    vec3 planet_pos;     /* Posição do planeta */
    float planet_radius; /* Raio do planeta */
} params;

/* === CONFIGURAÇÃO MODULAR (ESTÉTICA) === */
const vec3 COLOR_SKY   = vec3(0.37, 0.42, 0.46); /* Cinza Sky #606C76 */
const vec3 COLOR_ABYSS = vec3(0.0, 0.0, 0.15);   /* Azul Profundo #000026 */
const vec3 COLOR_GRID  = vec3(1.0, 1.0, 1.0);    /* Branco Puro */

const float GRID_SPACING = 0.5;
const float GRID_THICKNESS = 0.012;

/* === MÓDULO DE DEFORMAÇÃO === */
/* === MÓDULO DE DEFORMAÇÃO === */
float get_well_height(vec2 p) {
    float d = length(p);
    /* Distorção central suave mas profunda (Black Hole) */
    float h = -4.5 / (d * 0.8 + 1.2);
    
    /* Distorção do Planeta */
    float d_planet = length(p - params.planet_pos.xy);
    /* Massa relativa pequena, mas visível */
    h -= 0.8 / (d_planet * 2.0 + 0.5);

    /* Decaimento para bordas infinitas */
    float falloff = exp(-d * 0.02);
    return h * falloff;
}

float intersect_sphere(vec3 ro, vec3 rd, vec3 center, float radius) {
    vec3 oc = ro - center;
    float b = dot(oc, rd);
    float c = dot(oc, oc) - radius * radius;
    float h = b * b - c;
    if (h < 0.0) return -1.0;
    return -b - sqrt(h);
}

/* === MÓDULO DE RENDERIZAÇÃO DE MALHA === */
vec3 get_grid_color(vec3 p, vec3 rd, float t) {
    /* Fade por distância */
    float dist_fade = exp(-t * 0.015);
    
    /* Linhas de grade com anti-aliasing */
    vec2 g = abs(fract(p.xy / GRID_SPACING + 0.5) - 0.5) * GRID_SPACING;
    float line_x = smoothstep(GRID_THICKNESS, 0.0, g.x);
    float line_y = smoothstep(GRID_THICKNESS, 0.0, g.y);
    float grid = max(line_x, line_y);
    
    /* Cor base degradê azul */
    vec3 base = mix(COLOR_ABYSS * 0.5, COLOR_ABYSS, clamp(p.z * -0.2, 0.0, 1.0));
    
    /* Mistura malha branca */
    vec3 col = mix(base, COLOR_GRID, grid * dist_fade);
    
    return col;
}

/* === MÓDULO DE CÂMERA / PROJEÇÃO === */
void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= params.resolution.x || pixel.y >= params.resolution.y) return;

    vec2 uv = (vec2(pixel) / params.resolution) * 2.0 - 1.0;
    uv.x *= params.resolution.x / params.resolution.y;

    /* Configuração de Câmera: Ângulo Alto (Conforme Imagem 2) */
    vec3 ro = vec3(0.0, -25.0, 15.0); /* Posição recuada e alta */
    vec3 target = vec3(0.0, 0.0, -5.0);
    
    vec3 ww = normalize(target - ro);
    vec3 uu = normalize(cross(ww, vec3(0.0, 0.0, 1.0)));
    vec3 vv = cross(uu, ww);
    
    /* Campo de visão estreito para imitar a perspectiva da imagem */
    vec3 rd = normalize(uv.x * uu + uv.y * vv + 2.0 * ww);

    /* Raymarching para superfície */
    float t = 0.0;
    vec3 color = COLOR_SKY; 
    bool hit = false;

    /* Check visual planet intersection first */
    float t_planet = intersect_sphere(ro, rd, params.planet_pos, params.planet_radius);
    
    /* Step adaptive para evitar erro de precisão no horizonte */
    for(int i=0; i<120; i++) {
        /* Se houve interseção com planeta antes do grid (aproximado usando t), desenha planeta */
        if (t_planet > 0.0 && t > t_planet) {
             /* Cor do planeta: Vermelho avermelhado com shadow simples */
             vec3 p_surf = ro + t_planet * rd;
             vec3 normal = normalize(p_surf - params.planet_pos);
             vec3 light = normalize(vec3(0.0, 0.0, 1.0)); /* Luz de cima */
             float diffuse = max(dot(normal, light), 0.1);
             color = vec3(0.8, 0.2, 0.2) * diffuse;
             hit = true;
             break;
        }

        vec3 p = ro + t * rd;
        float h = get_well_height(p.xy);
        
        float dist = p.z - h;
        if (dist < 0.01) {
            /* Hit detectado */
            color = get_grid_color(p, rd, t);
            hit = true;
            break;
        }
        
        t += max(dist * 0.7, 0.1);
        if (t > 150.0) break;
    }

    /* Background Sky vs Abyss gradient */
    if (!hit) {
        float sky_grad = clamp(rd.z * 5.0 + 0.5, 0.0, 1.0);
        color = mix(COLOR_ABYSS, COLOR_SKY, sky_grad);
    }

    /* Gamma Correction */
    color = pow(color, vec3(1.0/2.1));

    imageStore(output_image, pixel, vec4(color, 1.0));
}
